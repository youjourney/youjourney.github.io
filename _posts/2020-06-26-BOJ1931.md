---
title: "[백준] 회의실배정 (1931)(Kotlin)"
excerpt: 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.
categories:
  - Algorithm
tags:
  - Algorithm
  - BOJ
  - Kotlin
last_modified_at: 2020-06-26T17:35:00+0900
---
**[원본 문제](https://www.acmicpc.net/problem/1931)**

### 문제 설명

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.


### 입력

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.


### 출력

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.


### 테스트 케이스1

|입력|출력|
|-----|-----|
|11<br>1 4<br>3 5<br>0 6<br>5 7<br>3 8<br>5 9<br>6 10<br>8 11<br>8 12<br>2 13<br>12 14|4|


### 문제 풀이1

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader

data class Conference(val start: Int, val end: Int): Comparable<Conference> {
    override fun compareTo(other: Conference): Int {
        return if (this.end == other.end)
            this.start - other.end
        else
            this.end - other.end
    }
}

fun main() = with(BufferedReader(InputStreamReader(System.`in`))) {

    val n = readLine().toInt()
    val seq: MutableList<Conference> = mutableListOf()

    repeat(n) {
        val (start: Int, end: Int) = readLine()
            .split(" ")
            .map { it.toInt() }

        seq.add(Conference(start, end))
    }

    seq.sort()

    var count = 1
    var endTime = seq[0].end

    for (i in 1 until n) {
        if (seq[i].start >= endTime) {
            endTime = seq[i].end
            count++
        }
    }
    println(count)
}
```
