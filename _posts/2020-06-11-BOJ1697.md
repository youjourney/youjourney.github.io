---
title: "[백준] 숨바꼭질 (1697)(Kotlin)"
excerpt: 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.
categories:
- boj
tags:
last_modified_at: 2020-06-11T15:20:00+09:00
---

**[원본 문제](https://www.acmicpc.net/problem/1697)**

### 문제 설명

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

### 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.


### 출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

### 입출력 예제1

|입력|출력|
|-----|-----|
|5 17|4|

### 입출력 예제2

|입력|출력|
|-----|-----|
|17 5|12|



```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.*

var nk: List<Int> = listOf()
var list = intArrayOf()
var max: Int = 0

fun main() = with(BufferedReader(InputStreamReader(System.`in`))) {

    nk = readLine()
        .split(" ")
        .map { it.toInt() }

    max = nk.max()!!.toInt()
    list = IntArray(max + 2) { 0 }

    bfs(nk[0])

}

fun bfs(start: Int) {

    val queue: LinkedList<Int> = LinkedList()
    queue.add(start)
    list[start] = 1

    while (queue.isNotEmpty()) {

        val now: Int = queue.poll()

        if (list[nk[1]] != 0) break

        if (now + 1 in 0..max + 1 && list[now + 1] == 0) {
            queue.add(now + 1)
            list[now + 1] = list[now] + 1
        }
        if (now - 1 in 0..max + 1 && list[now - 1] == 0) {
            queue.add(now - 1)
            list[now - 1] = list[now] + 1
        }
        if (now * 2 in 0..max + 1 && list[now * 2] == 0) {
            queue.add(now * 2)
            list[now * 2] = list[now] + 1
        }

    }

    println(list[nk[1]] - 1)

}
```
